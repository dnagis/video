#!/usr/bin/python

#Travail sur output YOLOv3, basé sur HelloYoloV3 dans mon dossier


import cv2 as cv
import numpy as np
import time
import sys

WHITE = (255, 255, 255)
img = None
img0 = None
outputs = None

#PATH prepended aux fichiers weight, config, class names...
PATH='/initrd/mnt/dev_save/packages/cv_dnn_data/detection/yolov3-opencv/'

# Load names of classes 
#J'ai pris le fichier de noms de classes:dans les sources openCV dans opencv-4.6.0/samples/data/dnn/
classes = open(PATH+'object_detection_classes_yolov3.txt').read().strip().split('\n')
np.random.seed(42)


# Give the configuration and weight files for the model and load the network.
net = cv.dnn.readNetFromDarknet(PATH+'yolov3.cfg', PATH+'yolov3.weights') #
net.setPreferableBackend(cv.dnn.DNN_BACKEND_OPENCV)
# net.setPreferableTarget(cv.dnn.DNN_TARGET_CPU)

# determine the output layer
ln = net.getLayerNames()
#print(len(ln), ln) #len=254

ln = [ln[i - 1] for i in net.getUnconnectedOutLayers()]

IMAGE_FILE = sys.argv[1]

img = cv.imread(IMAGE_FILE)






blob = cv.dnn.blobFromImage(img, 1/255.0, (416, 416), swapRB=True, crop=False)

net.setInput(blob)

#Premier résultat: 3 groupes selon taille
outputs = net.forward(ln)
print("type de outputs: ", type(outputs)) 						# <class 'tuple'>
print("len de outputs: ", len(outputs))							# 3
print("type du premier element de outputs: ", type(outputs[1])) # <class 'numpy.ndarray'> (idem pour chacun des 3
print("np.shape(outputs[0]):", np.shape(outputs[0])) # (507, 85)
print("np.shape(outputs[1]):", np.shape(outputs[1])) # (2028, 85)
print("np.shape(outputs[2]):", np.shape(outputs[2])) # (8112, 85)


#Explication des arrays de taille 85
#Le fichier des classes object_detection_classes_yolov3.txt contient 80 classes d'objets
#The network outputs bounding boxes are each represented by a vector of a number of classes + 5 elements (80+5 = 85)
#The first 4 elements represent the center_x, center_y, width, and height. The fifth element represents the confidence that the bounding box encloses an object.
#The rest of the elements are the confidence associated with each class (i.e., object type). The box is assigned to the class corresponding to the highest score for the box.



# combine ("aplatir") the 3 outputs groups into 1 (10647, 85)
# large objects (507, 85)
# medium objects (2028, 85)
# small objects (8112, 85)
outputs = np.vstack(outputs) #(10647, 85)

#print("np.shape(outputs):", np.shape(outputs)) #(10647, 85)
#print(outputs[10000]) #voir un exemple

#pour avoir accès aux résultats intéressants
i=0

for output in outputs:
	scores = output[5:] #pour chaque array de len=85, on récupère seulement à partir de l'index 5 (i.e. les CI pour chaque classe)
	
	#Afficher les 80 CI à chaque fois qu'on a au moins une valeur > 0
	if (cv.countNonZero(scores) > 0):
		print("@index en cours=", i)
		print("au moins une valeur de CI > 0")
		print(scores)
	
	classID = np.argmax(scores) #des 80 classes (object_detection_classes_yolov3.txt) celle qui a la valeur max
	confidence = scores[classID] #La confidence est la valeur à l'index de la classID	
	#classID == 0 --> class = "person". 
	if ((classID==0) and (confidence>0.9)):		
		print("person CI=", confidence)
	
	i+=1	

print("dernier index analysé=", i)






